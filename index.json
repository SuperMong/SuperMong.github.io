[{"content":"Promise is object used to handle asynchronous task, it represents the completion or failure of an asynchronous task.\nOld School Before promise appeared, we use callback function to write asynchronous code. Usually this format:\nfunction async(value, successCallback, failureCallback) { // ...  if (someCondition) successCallback(value); if (otherCondition) failureCallback(value); } Callback is good, but it has some shortages, the most obvious is callback hell. What happends to nested asynchronous tasks?\nasync(value, function(value) { // ...  async(newValue, function(newValue) { // ...  async(anotherValue, function(anotherValue) { // ...  async(finalValue, function(finalValue) { // ...  }, failureCallback); }, failureCallback); }, failureCallback); }, failureCallback); To be honest, trying to understand such code is suicidal, we desperately need simpler code.\nNew School In order to solve shortcomings of callback, promise are here. Using promise, we can write linear code like this:\nvar p = new Promise(function(resolve, reject) { // ... }).then(function(value) { // ... }).then(function(newValue) { // ... }).then(function(finalValue) { // ... }).catch(failureCallback); It\u0026rsquo;s easy to write, read and change, linear code makes everyone happy. Let\u0026rsquo;s start learning it right now!\nConstructor First study how to use constructor to creat a new promise object. Usually, we using constructor like this:\nvar p1 = new Promise((reslove, reject) =\u0026gt; { // do something immediately...  // when success  resolve(result); // when failure  reject(reason); }); A promise object associates an execution function which has two function parameters: resolve and reject. The execution function will run immediately, if asynchronous task is successfully completed, calling function resolve with the result; if asynchronous task is failed, calling function reject with the reason (usually a error object). What exactly these two functions do? Don\u0026rsquo;t worry, we\u0026rsquo;ll know it later.\nStates Every promise object has three states, respectively indicate the success, failure and in progress of the asynchronous task:\n pending: waiting for results fulfilled: operation success rejected: operation failed  The conversion between these three states are simple: If a promise object is in state pending, the state of it can be changed to fulfilled or rejected. But if a promise object is in state fulfilled or rejected, the state of it can\u0026rsquo;t be changed.\nHow does a promise object change its state? The answer is function resolve and reject: the resolve will set the state of the promise object to fulfilled; the reject will set the state of the promise object to rejected. So this is how things are: At first every promise object is in state pending, after the asynchronous task is completed, call resolve or reject according to the situation, these two functions will change the state of the promise object.\nNotice: Usually, if a promise object is in state fulfilled or rejected, we call it is in state settled, or just call it is resolved.\nChain Call In order to understand promise chain call, we have to know two methods, then and catch:\n  then: puts callback function(s) in a queue, return a new promise object\nvar p2 = p1.then(successCallback, failureCallback);   catch: actually a special then (just has failureCallback), specially used to handle errors and exceptions, catch and handle all errors and exceptions thrown by then before it, and also return a new promise object\nvar p3 = p2.then(successCallback) .then(successCallback) .catch(failureCallback);   The best thing of promise is methods Promise.prototype.then() and Promise.prototype.catch() will return a new promise object, which means it supports chain call.\nNow the question is how to call these callback functions? If the state of promise is pending, these functions will be put in to a queue, resolve and reject will call them in order and pass the return value after change the state of the promise object; if the state is settled, just call callback functions immeiately (resolve call successCallbacks and pass the return value, reject call failureCallbacks and pass the reason).\nWhat happens if a callback function return a promise object? The promises of a chain are nested, they get popped like the top of a stack. The first promise in the chain is most deeply nested and is the first to pop:\n(promise_D, (promise_C, (promise_B, (Promise_A))))\nWhen a return value is a promise object, the effect is a dynamic replacement. The return causes a promise to be popped, but the return promise is pushed into its place. For the nesting shown above, suppose the .then() associated with \u0026ldquo;promise_B\u0026rdquo; returns \u0026ldquo;promise_X\u0026rdquo;. The resulting nesting would look like this:\n(promise_D, (promise_C, (promise_B, (Promise_X))))\n","permalink":"https://supermong.github.io/posts/javascript-promise/","summary":"Promise is object used to handle asynchronous task, it represents the completion or failure of an asynchronous task.\nOld School Before promise appeared, we use callback function to write asynchronous code. Usually this format:\nfunction async(value, successCallback, failureCallback) { // ...  if (someCondition) successCallback(value); if (otherCondition) failureCallback(value); } Callback is good, but it has some shortages, the most obvious is callback hell. What happends to nested asynchronous tasks?\nasync(value, function(value) { // .","title":"Javascript Promise"},{"content":"Prototype chain of javascript is confuses me for a long time. This blog writes down my understanding.\nJavaScript only has one conscruct: object. Every object has a property which points to its prototype object, and this prototype object also has a prototype object, until one prototype is null. This structure is called prototype chain.\nWhen accessing the perproties of an object, javascript first looks in the object itself, if it is not found, it will continue searching along the prototype chain until it finds or reaches the end of the chain.\nPrototype For function, the property prototype points to its prototype object. For another object, the property [[Prototype]] points to its prototype object, which is the prototype object of its constructor.\nNotice: a function is also a object in javascript, so function also has property [[Prototype]] (but other kinds of objects do not have property prototype).\nFor example, there is a constructor Animal:\nfunction Animal(food, family) { this.food = food; this.species = family; } var animal1 = new Animal; console.log(animal1.[[Prototype]] === Animal.prototype); // true The Animal.prototype has two properties worth noting, constructor and [[Prototype]]:\n constructor: points to its constructor: Animal [[Prototype]]: points to its prototype: usually Object.prototype  Object is at the top of almost all prototype chains, the [[Prototype]] and Object.prototype.[[Prototype]] of it are null.\nInheritance We can use prototype chain to achieve inheritance, this needs a empty function:\nfunction Cat(name) { // Inheritance from Animal.  Animal.call(this, fish, \u0026#34;cat\u0026#34;); this.name = name; } // Prototype chain now is: // Cat.prototype --\u0026gt; Object.prototype --\u0026gt; null // There is no inheritance relationship between Cat and Animal, we have to make prototype chain right:  function F() {} F.prototype = Animal.prototype; Cat.prototype = new F; Cat.prototype.constructor = Cat; // Now prototype chain is: // Cat.prototype --\u0026gt; Animal.prototype --\u0026gt; Object.prototype --\u0026gt; null  var cat1 = new Cat(\u0026#34;Mong\u0026#34;); console.log(cat1.[[Prototype]] === Cat.protptype); // true console.log(Cat.prototype.[[Prototype]] === Animel.prototype); // true The code above implements inheritance relationship, but it\u0026rsquo;s a bit complicated. Fortunately, there is a more simplified method:\nfunction Cat(name) { Animal.call(this, fish, \u0026#34;cat\u0026#34;); this.name = name; } Cat.prototype = Object.create(new Animal); Cat.prototype.constructor = Cat; Method Object.create creates a new object, the prototype of the new object is the first parameter passed in when method is called.\n","permalink":"https://supermong.github.io/posts/javascript-prototype-chain/","summary":"Prototype chain of javascript is confuses me for a long time. This blog writes down my understanding.\nJavaScript only has one conscruct: object. Every object has a property which points to its prototype object, and this prototype object also has a prototype object, until one prototype is null. This structure is called prototype chain.\nWhen accessing the perproties of an object, javascript first looks in the object itself, if it is not found, it will continue searching along the prototype chain until it finds or reaches the end of the chain.","title":"JavaScript Prototype Chain"},{"content":"Object is always an important concept in object-based language, and JavaScript is a simple object-based language.\nAn object is a collection of properties. And a property is an association between a key and a value, the value can be a function, in witch case the property is known as a method.\nCreat Object There are three ways to creat an object:\n  Object Initializer:\nvar obj = { property_1: value_1, property_2: value_2, property_3: value_3, };   Object Constructor:\nfunction Obj(property_1, property_2, property_3) { this.property_1 = property_1; this.property_2 = property_2; this.property_3 = property_3; } var myObj = new Obj(p1, p2, p3);   Object.Creat Method: Allow you to create a new object with an old object as the prototype.\nvar oldObj = { p1: v1, p2: v2, p3: v3 }; var newObj = Object.Creat(oldObj);   Use Object It\u0026rsquo;s easy to use an object. Just like other languages:\nobjectname.property or:\nobjectname[property] There are two ways to add properties to objects:\n  Just add property to this one object, does not affect other objects of same type:\nvar obj1 = new Obj(); // An object without property \u0026#39;color\u0026#39; obj1.color = \u0026#34;red\u0026#34;; // Add property \u0026#39;color\u0026#39; to obj1   Add property to all objects of this type:\nvar obj2 = new Obj(); // An object without property \u0026#39;color\u0026#39; Obj.property.color = null; // Add property \u0026#39;color\u0026#39; to all objects of type \u0026#39;Obj\u0026#39; obj2.color = \u0026#39;blue\u0026#39;; // Using new property   Getter and Setter Getter is a method to get the value of a specific property, and setter is a method to set the value of a specific property. Getter must be parameterless, setter must have one parameter.\nThis example shows how to define and use getter and setter:\nvar o = { a: 0, get b() { return this.a + 1; }, set c(x) { this.a = x * 2; } }; console.log(o.a); // 0 console.log(o.b); // 1 o.c = 100; console.log(o.a); // 200 Use Object.defineProperty to define a declared function as getter or setter:\nvar o = { a: 0 }; Object.defineProperty(o, { \u0026#34;b\u0026#34;: { get: function() { return this.a + 1; } }, \u0026#34;c\u0026#34;: { set: function(x) { this.a = x * 2; } } }); These two ways are same, just choose what you like.\n","permalink":"https://supermong.github.io/posts/javascript-object/","summary":"Object is always an important concept in object-based language, and JavaScript is a simple object-based language.\nAn object is a collection of properties. And a property is an association between a key and a value, the value can be a function, in witch case the property is known as a method.\nCreat Object There are three ways to creat an object:\n  Object Initializer:\nvar obj = { property_1: value_1, property_2: value_2, property_3: value_3, };   Object Constructor:","title":"JavaScript Object"},{"content":"In college, compiler principles was a boring course for me, because I tought it was useless to me. After working for a while, I think mastering it is very helpful for me. So I started to learn it again (serious).\nToday, most programmers write programs in heigh-level languages. These languages provide a high level of abstraction to make programming easier. Naturally, there is a question: \u0026ldquo;How does the computer run these heigh-level programs?\u0026rdquo; And the answer is: \u0026ldquo;Using compiler or interpreter.\u0026rdquo;\nThis blog introduces what compiler and interpreter is, their defferences and the structure fo compiler.\nCompiler and Interpreter Interpreter comes first, which directly uses input provided by user to perform the specified operation in the source code. The input of interpreter is data and source code, and the output is the result of source code. Interpreter is good, but it has two disadvantages: 1.occupies memory when running the program 2.running slow\nTo overcome the shortcommings of interpreter, compiler appear. A compiler is a program that can translate source code into object code. The input of compiler is source code only, and the output is the object code. After getting object code, using assembler and linker to get executable program. The executable program obtained in this way is 10 to 20 times faster than using interpreter, and computer can run program without compiler.\nIs the compiler better than interpreter in any way? The answer is no, for example, interpreter provides better error checking. Compiler and interpreter each has their advantages. Following table shows the differencs between them:\n   Compiler Interpreter     off-line on-line   quick slow   worse error checking better error checking   not cross platform cross platform   input: source code input: source code and data   output: object code output: result of program    Structure of Compiler Compiler is complicated, in order to make it easier to design and understand, we divided it into two parts: Front end for processing input and back end for processing output.\nFurther more, front end can be divided into lexical analysis and word meaning analysis, back end can be divided into code generation and code optimization, etc. So we can think of compiler as a pipeline composed of multiple phases.\nFor example, a simple compiler structure is:\nsource code \u0026ndash;\u0026gt; lexical analysis \u0026ndash;\u0026gt; gramma analysis \u0026ndash;\u0026gt; semantic analysis \u0026ndash;\u0026gt; code generation \u0026ndash;\u0026gt; object code\nSource code enters the compiler and then passes through the pipline to become object code.\n","permalink":"https://supermong.github.io/posts/compiler-principles-introduce/","summary":"In college, compiler principles was a boring course for me, because I tought it was useless to me. After working for a while, I think mastering it is very helpful for me. So I started to learn it again (serious).\nToday, most programmers write programs in heigh-level languages. These languages provide a high level of abstraction to make programming easier. Naturally, there is a question: \u0026ldquo;How does the computer run these heigh-level programs?","title":"Compiler Principles Introduce"},{"content":"Regular Expression is a powerful and complex tool for processing string. Using it can greatly improve work efficiency, but due to its complexity, novices are often discouraged.\nI have learned regular expression many times, but I forget everytime bucause lack of practice. So I writing this blog to remind me that only use it to master it.\nTODO Compilers principles first.\n","permalink":"https://supermong.github.io/posts/regular-expression-basics/","summary":"Regular Expression is a powerful and complex tool for processing string. Using it can greatly improve work efficiency, but due to its complexity, novices are often discouraged.\nI have learned regular expression many times, but I forget everytime bucause lack of practice. So I writing this blog to remind me that only use it to master it.\nTODO Compilers principles first.","title":"Regular Expression Basics"},{"content":"Due to the high cost of living in Beijing and my shortage of wages, I have to cook by myself to save some money. But cooking is a pain for me ( I\u0026rsquo;m lazy ), so i bought an air fryer ( It\u0026rsquo;s cheap and easy to use ).\nThis blog is used to record my air fryer recipe.\nFries  Buy semi-finished fries Preheat the air fryer at 180 degrees for 5 minutes Put semi-finished fries in to air fryer Bake at 200 degrees for 10 to 15 minutes  TODO  Orleans Drumsticks Fried Dumpling Steak  ","permalink":"https://supermong.github.io/posts/my-air-fryer-recipe/","summary":"Due to the high cost of living in Beijing and my shortage of wages, I have to cook by myself to save some money. But cooking is a pain for me ( I\u0026rsquo;m lazy ), so i bought an air fryer ( It\u0026rsquo;s cheap and easy to use ).\nThis blog is used to record my air fryer recipe.\nFries  Buy semi-finished fries Preheat the air fryer at 180 degrees for 5 minutes Put semi-finished fries in to air fryer Bake at 200 degrees for 10 to 15 minutes  TODO  Orleans Drumsticks Fried Dumpling Steak  ","title":"My Air Fryer Recipe"},{"content":"Closure is one of the most important features of JavaScript, and its hard to understand. As a JavaScript novice, I write down my understanding of closure here.\nFunction scope Let\u0026rsquo;s start with function scope. The rule of function scope is simple: Inside function can access all the scopes that outside function can access, but outside function can\u0026rsquo;t access inside function\u0026rsquo;s scope.\nfunction outside() { var outVar = \u0026#34;out variable\u0026#34;; function inside() { var inVar = \u0026#34;in variable\u0026#34;; return outVar + \u0026#34; + \u0026#34; + inVar;\t// return: \u0026#34;out variable + in variable\u0026#34;  } return outVar + \u0026#34; + \u0026#34; + inVar;\t// Error: can not access variable \u0026#39;inVar\u0026#39; } What happens if multiple functions are nested?\nfunction A() { var aVar = 1; function B() { var bVar = 2; function C() { var cVar = 3; return aVar + bVar + cVar;\t// return：1 + 2 + 3 = 6  } } } Function A contains function B, so B can access A. Then B contains function C, so C can access B which can access A, therefore C can access A. This is called scope chaining.\nClosure The scope rule of function mentioned earlier lead to two results:\n Variables of inner function are encapsulated If inner function survive beyond the life of the outer function, the scope of outer function can also survive with inner function ( Because it is still been accessed by inner function )  When inner function is accessed outside the scope of the outer function, a closure is created. Using closure, we can access the variables inside the function and keep these variables in momory.\nA simple example:\nfunction outer() { var outerVar = 0; return function inner() { outerVar += 1; return outerVar; } } var innerFunc = outer(); innerFunc();\t// 1 innerFunc();\t// 2 The variable outerVar in function outer survive with innerFunc, we can access it by calling innerFunc.\nNotice: Closure keep all variables in the memory, the memory consumption is large. Don\u0026rsquo;t abuse closure.\n","permalink":"https://supermong.github.io/posts/javascript-closure/","summary":"Closure is one of the most important features of JavaScript, and its hard to understand. As a JavaScript novice, I write down my understanding of closure here.\nFunction scope Let\u0026rsquo;s start with function scope. The rule of function scope is simple: Inside function can access all the scopes that outside function can access, but outside function can\u0026rsquo;t access inside function\u0026rsquo;s scope.\nfunction outside() { var outVar = \u0026#34;out variable\u0026#34;; function inside() { var inVar = \u0026#34;in variable\u0026#34;; return outVar + \u0026#34; + \u0026#34; + inVar;\t// return: \u0026#34;out variable + in variable\u0026#34;  } return outVar + \u0026#34; + \u0026#34; + inVar;\t// Error: can not access variable \u0026#39;inVar\u0026#39; } What happens if multiple functions are nested?","title":"JavaScript Closure"},{"content":"Same as all ( maybe ) programming languages, JavaScript has some statements for loop:\n while do\u0026hellip;while for for\u0026hellip;in for\u0026hellip;of label break and continue  Most of them are common in other languages, I only introduce for...in, for...of and label here.\nfor\u0026hellip;in The for...in is a statement can traverse all enumerable properties of an object.\nfor (variable in object) { statements } The following function can return a string that lists the propertie names and their values:\nfunction list(obj) { let result = \u0026#34;\u0026#34;; for (let i in obj) { result += i + \u0026#34;: \u0026#34; + obj[i] + \u0026#34; \u0026#34;; } return result; } For an object person with properties name and sex, list(person) will return \u0026ldquo;name: SuperMong sex: male \u0026ldquo;.\nNotice: If you want to traverse enumerable properties of an object, for...in is a good choice. But for an array (map, set, and so on), for...in will traverse user-defined properties, not array elements.\nfor\u0026hellip;of Dirrerent from for...in, for...of statement traverse values of an object.\nfor (variable of object) { statements } The following code can make it clearly:\nvar arr = [5, 2, 6]; let sum = 0; for (let n of arr) { sum += n; // The value of sum is 5 + 2 + 6 = 13; } label The label can identify statements. It always be used with break and continue to control loops.\nlabel: statements A simple example:\nlet x = 0; someLoop: while (true) { x += 1; let y = 0; while (true) { y += 1; if (y === 9) { break someLoop; } } } ","permalink":"https://supermong.github.io/posts/javascript-loop-and-iteration/","summary":"Same as all ( maybe ) programming languages, JavaScript has some statements for loop:\n while do\u0026hellip;while for for\u0026hellip;in for\u0026hellip;of label break and continue  Most of them are common in other languages, I only introduce for...in, for...of and label here.\nfor\u0026hellip;in The for...in is a statement can traverse all enumerable properties of an object.\nfor (variable in object) { statements } The following function can return a string that lists the propertie names and their values:","title":"JavaScript Loop and Iteration"},{"content":"Since I used git, I have always wanted to know how to write a concise and clear commit message? After entering the job, I found that Angular\u0026rsquo;s specification is the most popular specification. So, let\u0026rsquo;s start learning it.\nCommit Message Format Each commit message consists of a header, a body and a footer:\n\u0026lt;header\u0026gt; \u0026lt;BLANK LINE\u0026gt; \u0026lt;body\u0026gt; \u0026lt;BLANK LINE\u0026gt; \u0026lt;footer\u0026gt; Header A commit message must has header, and it has its own format:\n\u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;short summary\u0026gt;\nThe type field is mandatory, must be one of following:\n build: Changes that affect the build system or external dependencies ci: Changes to our CI configuration files and scripts docs: Documentation only changes feat: A new feature fix: A bug fix pref: A code change that improves performance refactor: A code change that neither fixes a bug nor adds a feature test: Adding missing tests or correcting existing tests  The scope field is optional, should be the name of the package affected.\nAnd summary is the description of the commit. It\u0026rsquo;s also mandatory and there are some rules to write it:\n use imperative don\u0026rsquo;t capitalize the first letter no dot (.) at the end  Body If commit type is docs, then body is required, In other cases, it\u0026rsquo;s optional.\nJust like summary, explain why you are making the change.\nFooter The footer can contain information for breaking changes and deprecations, and is also a place to reference issues.\n","permalink":"https://supermong.github.io/posts/how-to-wirte-git-commit-message/","summary":"Since I used git, I have always wanted to know how to write a concise and clear commit message? After entering the job, I found that Angular\u0026rsquo;s specification is the most popular specification. So, let\u0026rsquo;s start learning it.\nCommit Message Format Each commit message consists of a header, a body and a footer:\n\u0026lt;header\u0026gt; \u0026lt;BLANK LINE\u0026gt; \u0026lt;body\u0026gt; \u0026lt;BLANK LINE\u0026gt; \u0026lt;footer\u0026gt; Header A commit message must has header, and it has its own format:","title":"How to write a commit message in Git?"},{"content":"Hello world, I\u0026rsquo;m SuperMong, come from China.\nThis is my first post on the blog. In the future, I will post some of my study notes and essays in English ( A challenge ).\nIt\u0026rsquo;s not clear yet, but this is the list of notes I am going to post:\n   note state     HTML undo   JavaScript undo   TypeScript undo   Design Patterns (GoF) undo   Docker undo    ","permalink":"https://supermong.github.io/posts/my-first-post/","summary":"Hello world, I\u0026rsquo;m SuperMong, come from China.\nThis is my first post on the blog. In the future, I will post some of my study notes and essays in English ( A challenge ).\nIt\u0026rsquo;s not clear yet, but this is the list of notes I am going to post:\n   note state     HTML undo   JavaScript undo   TypeScript undo   Design Patterns (GoF) undo   Docker undo    ","title":"My First Post"}]